## Azure AAD aka Entra ID

An app can interact with resource usig access keys. Another approach is to regiter an app id object in AAD, assign it access on the resource and then use that app identity in the app to access the object.<br>
To do this follow these steps:<br>
- Go to AD -> App Registrations -> New REgistration
- Give a name such as "MyXyzApp" and hit register
- Once registered you will get "Application / ClientId" and "Directory / tenant ID" in properties, we need these to connect from our app.
- Under "MyXyzApp" => Certificates and Secret you can create a new client secret (aka Password), this is also needed in app. It is a description / key pair such as "secret" / "Xwrt312321313gvaad".
- Next go to your resource and click on "Access Control"
- Click on "Add Role Assignment", select a Role such as "Reader" role, and assign "MyXyzApp" to the "Reader" role
- This will let the MyXyzApp read the properties of that particular stoarge account
- Next look for "Storage Blob Data Reader" role and assign "MyXyzApp" to the same
- Now come back to app code (c# app here)
- We dont need Access Keys/ Connection string anymore
- Instead we need "tenantId", "clientId", and "clientSecret"

  Here is how the code looks:
  ```c#
  using Azure.Identity;
  using Azure.Storage.Blobs;
  
  string tenantId = "70c0f6d9-7f3b-4425-a6b6-09b47643ec58";
  string clientId = "b4d0b1b0-21f6-4b57-a6cc-ca982114e340";
  string clientSecret = "1ym8Q~uaRr2d5LtGSB9K36JxhJzN-MB2iMxirbyr";
  
  string blobURI = "https://appstore500505.blob.core.windows.net/data/script.sql";
  string filePath = "C:\\tmp1\\script.sql";
  
  ClientSecretCredential clientCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
  
  BlobClient blobClient = new BlobClient(new Uri(blobURI),clientCredential);
  
  await blobClient.DownloadToAsync(filePath);
  
  Console.WriteLine("The blob is downloaded");
  ```

## Microsoft Graph - https://developer.microsoft.com/en-us/graph

RESTful API to get the details about your users/ groups/ calendars etc.

Step 1: Authorize yourself so you can access the Entra ID data using MS Graph API. This is done via Access Token.
- We will then use the Access Token to access the data via Postman tool
- Entra ID -> App Registrations -> New Registration
- Enter "Postman" as the name and hit "Register".
- Now that we created the app registration "Postman", we need to give access to it to read Entra ID data
- For that click on "Postman" -> Manage | API Permissions
- By default there is already a "User.Read" permission listed there. Click on "..." and remove it.
- Click on "Add a Permission", select Microsoft Graph => Application Permissions
- Scroll down to "User" and select "User.ReadAll" and hit "Add Permissions".
- There are diffenet type of permissions there such as "calendars" to read calendar data.
- Click on "Grant admin consent for default directory"
- Now we can access the data from Postman tool

Step 2: Get the token
- Go to Postman app registration -> Overview -> Endpoints and copy the "OAuth 2.0 token endpoint (v2)". This is how it looks
- https://login.microsoftonline.com/1a738633-1476-4d96-828c-fa5727a31ca7/oauth2/v2.0/token
- In the POSTMAN tool, create a POST request with the above URL
- Select "Body | x-www-form-urlencoded"
- For Key enter "grant_type", and "client_credentials" as Value.
- Next Key is "client_id" and Value is "Application (client) ID" value from Postman app registration | Overview
- Next generate a secret and copy the "Value"
- Add another Key named "client_secret" and set the Value as one copied above
- Add another Key with name "scope" and Value as ""
- Click "Send"
- In the response we get an access token as below:
  ```json
  {
    "token_type": "Bearer",
    "expires_in": 3599,
    "ext_expires_in": 3599,
    "access_token": "eyJ0eXAiOiJKV1QiLCJub25jZSI6ImNFZW9NQ2UxazJHLWpTV1huR1l6LXZ1SzQ5OENjWHB4cUQ3ZjRaTkpFMTQiLCJhbGciOiJSUzI1NiIsIng1dCI6InEtMjNmYWxldlpoaEQzaG05Q1Fia1A1TVF5VSIsImtpZCI6InEtMjNmYWxldlpoaEQzaG05Q1Fia1A1TVF5VSJ9.eyJhdWQiOiJodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20iLCJpc3MiOiJodHRwczovL3N0cy53aW5kb3dzLm5ldC8xYTczODYzMy0xNDc2LTRkOTYtODI4Yy1mYTU3MjdhMzFjYTcvIiwiaWF0IjoxNzEyMDg1MDA0LCJuYmYiOjE3MTIwODUwMDQsImV4cCI6MTcxMjA4ODkwNCwiYWlvIjoiRTJOZ1lMaC9hZWF5WDlzVlZ2ZituV25oOU9kUUxBQT0iLCJhcHBfZGlzcGxheW5hbWUiOiJQb3N0bWFuIiwiYXBwaWQiOiJmNzNiNjU0YS04Y2Y1LTQ2MzYtOTcxYS05OWY1ODQ0NDQwYWYiLCJhcHBpZGFjciI6IjEiLCJpZHAiOiJodHRwczovL3N0cy53aW5kb3dzLm5ldC8xYTczODYzMy0xNDc2LTRkOTYtODI4Yy1mYTU3MjdhMzFjYTcvIiwiaWR0eXAiOiJhcHAiLCJvaWQiOiIyYjg2ZDlhYi05ZWIzLTQ4YzItODIzMS01ZDViYjAwMjI1NjEiLCJyaCI6IjAuQVVZQU00WnpHbllVbGsyQ2pQcFhKNk1jcHdNQUFBQUFBQUFBd0FBQUFBQUFBQUJHQUFBLiIsInJvbGVzIjpbIlVzZXIuUmVhZC5BbGwiXSwic3ViIjoiMmI4NmQ5YWItOWViMy00OGMyLTgyMzEtNWQ1YmIwMDIyNTYxIiwidGVuYW50X3JlZ2lvbl9zY29wZSI6Ik5BIiwidGlkIjoiMWE3Mzg2MzMtMTQ3Ni00ZDk2LTgyOGMtZmE1NzI3YTMxY2E3IiwidXRpIjoieXc3ZEU3eGQ3VXVzOFoxLVRSQ1RBQSIsInZlciI6IjEuMCIsIndpZHMiOlsiMDk5N2ExZDAtMGQxZC00YWNiLWI0MDgtZDVjYTczMTIxZTkwIl0sInhtc190Y2R0IjoxNjMzNDU1NTUzfQ.DLfYvBZeblHSsNjpns0O9R8NS0XPblStZW82zuJVkkPI4Q-xwEtvbdqCoO-vC2hjGpbOdsRSvrKi5lehPIKZ6VSz5g9j9KHe8QDz7-3sDyQ2y61NPpLiPcRGszwgx3Z4cILX2jm-Sb8GnbQf6sK63NDc7-rA_bIrUjKLS2SSV85khgsStxCgBFDz1ZmunyVM5rOTakW9Da2WzmhMrMVifEfSYxkEA0Tw3IVWS8WZ264682AH9MQrb5Eo1pUYa5itoTcn99UQOCywKsN2ZvhmMNcDvwlVvHy-9-q9B0GUvP0EQ_FOsryIfkdHKkb3yexepjysAN8NMdQbPOI-1f5POA"
  }
  ```
  - This access_toke is our Key

  Step 3: Getting the Users
  - Go to Postman tool and run a "GET" type request "https://graph.microsoft.com/v1.0/users"
  - You can get the requests from https://developer.microsoft.com/en-us/graph/graph-explorer
  - Under the Headers add "Authorization" as the Key and Value as "Bearer eyJ0eXA.....POI-1f5POA"
  - Basically if you look at json above our token is of type Bearer so we weppend that to "Bearer " to make the Value above
  - Hit Send
 
  The response is our users data from Entra ID
  ```json
  {
    "@odata.context": "https://graph.microsoft.com/v1.0/$metadata#users",
    "value": [
        {
            "businessPhones": [],
            "displayName": "aad_lab_user1",
            "givenName": null,
            "jobTitle": null,
            "mail": null,
            "mobilePhone": null,
            "officeLocation": null,
            "preferredLanguage": null,
            "surname": null,
            "userPrincipalName": "aad_lab_user1@vimalmalikhotmail.onmicrosoft.com",
            "id": "a170a08d-21b0-441b-ac28-3004066b314d"
        },
        {
            "businessPhones": [],
            "displayName": "Vimal Kumar",
            "givenName": "Vimal",
            "jobTitle": null,
            "mail": null,
            "mobilePhone": null,
            "officeLocation": null,
            "preferredLanguage": "en",
            "surname": "Kumar",
            "userPrincipalName": "vimalmalik_hotmail.com#EXT#@vimalmalikhotmail.onmicrosoft.com",
            "id": "70921be9-48aa-4b1a-9ea9-4b7a0e1c3f2c"
        }
    ]
  }
  ```

## Key Vault => Secrets aka Passwords, Encryptions Keys, and Certificates

### Encryption Key example
- Create a "Key Vault" resource named "appvaultvk"
- Create a "Key", this is RSA type Encryption key, name it "appkey-rsa"
- Register an app with EntraID, named "appvault"
- Assign "appvault" privileges on the appvaultvk by going to App Vault and "Access Control (IAM)"
- ```c#
  using Azure.Identity;
  using Azure.Security.KeyVault.Keys;
  using Azure.Security.KeyVault.Keys.Cryptography;
  using System.Text;
  
  string tenantId = "70c0f6d9-7f3b-4425-a6b6-09b47643ec58"; //from appvault
  string clientId = "b4d0b1b0-21f6-4b57-a6cc-ca982114e340"; //from appvault
  string clientSecret = "1ym8Q~uaRr2d5LtGSB9K36JxhJzN-MB2iMxirbyr"; //from appvault
  
  string keyvaultUrl = "https://appvaultvk.vault.azure.net/"; //app vault URL
  string keyName = "appkey-rsa";
  string textToEncrypt = "This a secret text";
  
  ClientSecretCredential clientSecretCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
  
  KeyClient keyClient = new KeyClient(new Uri(keyvaultUrl), clientSecretCredential);
  
  var key = keyClient.GetKey(keyName);
  
  // The CryptographyClient class is part of the Azure Key vault package
  // This is used to perform cryptographic operations with Azure Key Vault keys
  var cryptoClient = new CryptographyClient(key.Value.Id, clientSecretCredential);
  
  // We first need to take the bytes of the string that needs to be converted
  
  byte[] textToBytes = Encoding.UTF8.GetBytes(textToEncrypt);
  
  EncryptResult result = cryptoClient.Encrypt(EncryptionAlgorithm.RsaOaep, textToBytes);
  
  Console.WriteLine("The encrypted text");
  Console.WriteLine(Convert.ToBase64String(result.Ciphertext));
  
  // Now lets decrypt the text
  // We first need to convert our Base 64 string of the Cipertext to bytes
  
  byte[] ciperToBytes = result.Ciphertext;
  
  DecryptResult textDecrypted = cryptoClient.Decrypt(EncryptionAlgorithm.RsaOaep, ciperToBytes);
  
  Console.WriteLine(Encoding.UTF8.GetString(textDecrypted.Plaintext));
  
  Console.ReadKey();
  ```

### Secrets Example - DB Connection string

This is similar to encryption key example. In this case code is accessing a secret named "dbconnectionstring" that stores DB connection string. We use app id regsitration to access the vault, the registered app has access to Secret data

```c#
using Azure.Identity;
using Azure.Security.KeyVault.Secrets;
using sqlapp.Models;
using System.Data.SqlClient;

namespace sqlapp.Services
{
    // This service will interact with our Product data in the SQL database
    public class ProductService
    {
        private SqlConnection GetConnection()
        {
            string tenantId = "70c0f6d9-7f3b-4425-a6b6-09b47643ec58";
            string clientId = "b4d0b1b0-21f6-4b57-a6cc-ca982114e340";
            string clientSecret = "1ym8Q~uaRr2d5LtGSB9K36JxhJzN-MB2iMxirbyr";

            string keyvaultUrl = "https://appvault600909.vault.azure.net/";
            string secretName = "dbconnectionstring";
            
            ClientSecretCredential clientSecretCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
            SecretClient secretClient = new SecretClient(new Uri(keyvaultUrl), clientSecretCredential);

            var secret = secretClient.GetSecret(secretName);

            string connectionString = secret.Value.Value;

            return new SqlConnection(connectionString);
        }
        public List<Product> GetProducts()
        {
            List<Product> _product_lst = new List<Product>();
            string _statement = "SELECT ProductID,ProductName,Quantity from Products";
            SqlConnection _connection = GetConnection();
            
            _connection.Open();
            
            SqlCommand _sqlcommand = new SqlCommand(_statement, _connection);
            
            using (SqlDataReader _reader = _sqlcommand.ExecuteReader())
            {
                while (_reader.Read())
                {
                    Product _product = new Product()
                    {
                        ProductID = _reader.GetInt32(0),
                        ProductName = _reader.GetString(1),
                        Quantity = _reader.GetInt32(2)
                    };

                    _product_lst.Add(_product);
                }
            }
            _connection.Close();
            return _product_lst;
        }

    }
}
```

## Managed Identities and VM
In previous examples we registered an app and used it to access the Azure Resources. Note the following:

```c#
    string tenantId = "70c0f6d9-7f3b-4425-a6b6-09b47643ec58";
    string clientId = "b4d0b1b0-21f6-4b57-a6cc-ca982114e340";
    string clientSecret = "1ym8Q~uaRr2d5LtGSB9K36JxhJzN-MB2iMxirbyr";
```
As you see there is still a client secret needed in code which can be misused. Managed Identities solve this problem.<br>
If we are hosting our App on a azure VM then we can provide an ID to azure VM and use that ID to get access to Azure resources. To do this go to VM -> Security -> Identity -> System Assigned -> Enable Status.

Once you do the above, go to storage account, hit Access Control (IAM) -> click "Add role assignment", select "Reader" role, "Select Members", and add appvm to that. Appvm will belisted as a member there to select an assign too. Next select "Storage Blob data reader" and do the same, with that we have assigned access to appvm identity.

The DefaultAzureCredential() call in code below automatically picks up Access Token from diffenet sources on machine, in this case from Managed Identity of the VM. The below code when run on appvm will download the script.sql from storage account. Internally DefaultAzureCredential() retrieves the access token that is used to access data from storage account.

```c#
using Azure.Core;
using Azure.Identity;
using Azure.Storage.Blobs;

string blobURI = "https://appstore500505.blob.core.windows.net/data/script.sql";
string filePath = "D:\\tmp1\\script.sql";

TokenCredential tokenCredential = new DefaultAzureCredential();

BlobClient blobClient = new BlobClient(new Uri(blobURI), tokenCredential);

await blobClient.DownloadToAsync(filePath);
Console.WriteLine("The blob is downloaded");
```

## Managed Identities - getting the Access Token
From the VM you can use Instance Metadata Service (IMDS) to get the access token.

```c#
using Newtonsoft.Json;

using System.Collections.Generic;
using System.Net.Http.Headers;

string tokenUri = "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://storage.azure.com";
HttpClient httpClient = new HttpClient();
httpClient.DefaultRequestHeaders.Add("Metadata", "true");

HttpResponseMessage response = await httpClient.GetAsync(tokenUri);
string content = await response.Content.ReadAsStringAsync();

//Console.WriteLine(content);

Dictionary<string,string> values=JsonConvert.DeserializeObject<Dictionary<string,string>>(content);
foreach(KeyValuePair<string,string> pair in values)
{
    Console.WriteLine("Key is " + pair.Key);
    Console.WriteLine("Value is " + pair.Value);
}

Console.WriteLine(values["access_token"]);
// We can now access the blob
string applicationUri = "https://appstore500505.blob.core.windows.net/data/script.sql";
HttpClient httpClientStorage = new HttpClient();
httpClientStorage.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", values["access_token"]);
httpClientStorage.DefaultRequestHeaders.Add("x-ms-version", "2017-11-09");

HttpResponseMessage blobResponse = await httpClientStorage.GetAsync(applicationUri);
string blobContent = await blobResponse.Content.ReadAsStringAsync();

Console.WriteLine(blobContent);
Console.Read();
```

## Managed Identities and App Services such as Web App
Same idea, go to Security -> Identity -> System Assigned and enabled status to enable the Managed Identity. Rest of the code and steps are same as in case of VM. You can configure that identity in Azure Vault and then can read data from it directly  by using this line in code as before
```c#
TokenCredential tokenCredential = new DefaultAzureCredential();
```

```c#
    private SqlConnection GetConnection()
    {
        
        string keyvaultUrl = "https://appvault67768.vault.azure.net/";
        string secretName = "dbconnectionstring";

        TokenCredential tokenCredential = new DefaultAzureCredential();
        SecretClient secretClient = new SecretClient(new Uri(keyvaultUrl), tokenCredential);

        var secret = secretClient.GetSecret(secretName);

        string connectionString = secret.Value.Value;


        return new SqlConnection(connectionString);
    }
```

## Managed Identity - System Assigned vs User Assigned
System assigned will go away when a VM/App service is deleted. It is per resource but user assigned is when you create an identity and assign it to a VM/App Service. So if you create 10 VMs, you can assign same managed id to each of those. That way you dont have to assign access to 10 differeny system assigned IDs to a storage account.

https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview

For this you have to create a new resource of type "User Assigned Managed Identity" and give it a name such as "user_ass_id". You can then assign it to a VM/App Service.

## PS Script to assign a User Assigned Managed Id to a VM
```ps1
Connect-AzAccount

$ResourceGroupName ="app-grp"
$IdentityName="app-identity"

New-AzUserAssignedIdentity -ResourceGroupName $ResourceGroupName -Name $IdentityName -Location "North Europe"

$Identity=Get-AzResource -Name $IdentityName -ResourceGroupName $ResourceGroupName
$ResourceId=$Identity.Id
$VmName="appvm"

$vm = Get-AzVM -ResourceGroupName $ResourceGroupName -Name $VmName
Update-AzVM -ResourceGroupName $ResourceGroupName -VM $vm -IdentityType UserAssigned `
-IdentityID $ResourceId
```

## PS Script to assign a System Assigned Managed Id to a VM
```ps1
Connect-AzAccount

$ResourceGroupName="app-grp" 
$VmName="appvm"

$Vm=Get-AzVM -ResourceGroupName $ResourceGroupName -Name $VmName
Update-AzVM -ResourceGroupName $ResourceGroupName -VM $Vm -IdentityType SystemAssigned
```


