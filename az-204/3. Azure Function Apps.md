# Azure Function Apps - Resource of type "Function App"
Azure Functions is an event-based serverless compute experience to accelerate your development.
https://learn.microsoft.com/en-us/azure/azure-functions/

Azure Functions is a cloud service available on-demand that provides all the continually updated infrastructure and resources needed to run your applications. You focus on the code that matters most to you, in the most productive language for you, and Functions handles the rest. Functions provides serverless compute for Azure. You can use Functions to build web APIs, respond to database changes, process IoT streams, manage message queues, and more.

- Create a resource of type "Function App"
- Give it a unique name
- Select Code OR Conatiner as type
- Select runtime stack (.NET, Python, Java, Node.js, Custom Handler or PowerShell core)
- Select .NET Framework if .NET is selected above
- Select OS type - Linux or Windows

```c#
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace sqlfunction
{
    public static class GetProduct
    {
        [FunctionName("GetProducts")]
        public static async Task<IActionResult> RunProducts(
            [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req,
            ILogger log)
        {

            System.Collections.Generic.List<Product> products = new List<Product>();
            products.Add(new Product() { ProductID = 1, ProductName = "Laptop", Quantity = 100 });
            products.Add(new Product() { ProductID = 2, ProductName = "Desktop", Quantity = 150 });
            products.Add(new Product() { ProductID = 3, ProductName = "Tablet", Quantity = 95 });

            log.LogInformation("C# HTTP trigger function processed a request.");

            return new OkObjectResult(products);
        }

        [FunctionName("GetProduct")]
        public static async Task<IActionResult> RunProduct(
        [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req,
        ILogger log)
        {
            int productId = int.Parse(req.Query["id"]);

            System.Collections.Generic.List<Product> products = new List<Product>();
            products.Add(new Product() { ProductID = productId, ProductName = "Laptop", Quantity = 100 });

            log.LogInformation("C# HTTP trigger function processed a request.");

            string name = req.Query["name"];

            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
            dynamic data = JsonConvert.DeserializeObject(requestBody);
            name = name ?? data?.name;

            return new OkObjectResult(products);
        }

        [FunctionName("AddProduct")]
        public static async Task<IActionResult> AddProduct(
        [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,
        ILogger log)
        {
            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
            Product data = JsonConvert.DeserializeObject<Product>(requestBody);

            System.Collections.Generic.List<Product> products = new List<Product>();
            products.Add(data);

            log.LogInformation("C# HTTP trigger function processed a request.");

            return new OkObjectResult(products);
        }
    }
}
```

We can use Azure App Configuration to store SQLCOnnection string for Azure SQL Server and can then access it in code as:
```c#
    public static SqlConnection GetConnection()
    {
        string connString = Environment.GetEnvironmentVariable("SQLAZURECONNSTRING_SQLConnString");
        return new SqlConnection(connString);
    }
```
