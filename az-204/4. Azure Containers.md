# Containers (Compute Solutions)
- provision VMs
- configure, validate and deploy ARM temnplates
- configure container images for solutions
- publish an image to Azure Container Registry
- run containers by using Azure Container Instance

# Why Containers?
- isolation (app + libraries)
- portability 

# Docker
Docker Engine provides the runtime env.

Docker image is just a set of instructions on how to run a container instance off it.

- DockerHub is a repository of VMs
- When we launch a container, linux VM (say) will connect to DockerHub, download the image and create a container out of it
- You can go gto DockerHub, search for image such as nginx and run it on your machine
- sudo docker images will show you the images on your machine
- sudo docker run --name appnginx -p 80:80 -d nginx

To use Docker here are the steps:
- install docker engine on your machine
- find the image that you want to run (look it up on DockerHub)
- run it using "sudo docker run"
- or create an image based off your application

## Building a new image
To create from a .NET web app, simply publish it to a folder so that you have the webapp contents
- next build Dockerfile and place it along with the webapp code
- Dockerfile will have instructions on how to build my image
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY  . .
EXPOSE 80
ENTRYPOINT ["dotnet", "sqlapp.dll"]
```
1. The following command can be used to build a custom image<br>
sudo docker build -t sqlapp .

3. Use the following command as a reference to stop a running container<br>
sudo docker stop 9ec  [...9ec... is the first 3 characters of container id]

4. Then you can run a container out of your custom image<br>
sudo docker run --name sqlapp-1 -p 80:80 -d sqlapp

## Rebuilding image
"sudo docker ps" will show you the running containers<br>
"sudo docker rm 9ec" will remove the container<br>
"sudo docker rm sqlapp" will remove the image<br>

You can then rebuild/publish the image

We can also publish it on DockerHub so that other machines can also download and run an instance off it. OR publish it in Azure Container Registry (CR)

# Azure Container Registry
Repository for images. You can create a Azure CR resource (say appregistry2024) with a user id and password and later use that info to add images to it.

To do all this, you can install Azure CLI on a linux VM (refer install azure CLI on linux for that) and then use linux VM to publish images in CR.
- login in Azure CR using: sudo az acr login --name appregistry2024 --username <user> --password <pwd>
- next tag the sqlapp image we created previously with CR name
- sudo docker tag sqlapp appregistry2024.azurecr.io/sqlapp
- Push the image in CR
- sudo docker push appregistry2024.azurecr.io/sqlapp
- Now uder CR => Repositories you can see the sqlapp

It provides a fast and easy way to deploy containers.

## Multi stage Dockerfile
Earlier we built the code, publish to a folder, FTPed to a linux VM and there created the iamge of our web app.<br>

Here we have a Dockerfile that does build and create an image from .NET Core source code on linux VM itself

```Dockerfile
# https://hub.docker.com/_/microsoft-dotnet
FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build
WORKDIR /source

# copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore

# copy everything else and build app
COPY . .
RUN dotnet publish -c Release -o out

# final stage/image
FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY --from=build /source/out .
ENTRYPOINT ["dotnet", "sqlapp.dll"]
```

1. Build your new Docker image<br>
sudo docker build -t sqlapp-new .

2. Run your new container<br>
sudo docker run --name sqlapp-2 -p 80:80 -d sqlapp-new

## Azure Container Groups
This is a collection of containers that get schedules on the same host machine. They share the lifecycle, resources, local network and storage. The deployment is done via ARM or yaml file.

Here we can create a group of MySQL and sqlapp. Before all this it is a good practice to just create a resource of tyoe "MySQL" in azure and test your app outside of docker itself. On local; machine you can download and install MySQL Workbench and use it to connect to MySQL instance running in azure.

In .NET use MySql.Data in C# in order to use MySQL.

In DocketHub there is a MySQL image available that we can use to run on our linuxvm<br>
sudo docker run --name=mysql-instance -p 3306:3306 --restart on-failure -d -e MYSQL_ROOT_PASSWORD=Azure123 mysql

Then gon to linuxvm -> Settings -> Networking -> Add inbound port rule; and select MySQL as service and click on <Add>

Lets now containerize MySQL as we want it ti have our DB and data as well.

Here is Dockerfile to create a custom MySQL image. It starts with base image and runs SQL commands from 01.sql that creates Table and populates them

```
FROM mysql as base

ENV MYSQL_ROOT_PASSWORD=Azure123
ENV MYSQL_DATABASE=appdb

COPY 01.sql /docker-entrypoint-initdb.d/
```

```bash
1. Build the custom MySQL image
sudo docker build -t appsqlimage .

2. Run the image
sudo docker run -d -p 3306:3306 --name appsql appsqlimage

3. Connect to the container
sudo docker exec -it appsql bash
```

