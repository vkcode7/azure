# Containers (Compute Solutions)
- provision VMs
- configure, validate and deploy ARM temnplates
- configure container images for solutions
- publish an image to Azure Container Registry
- run containers by using Azure Container Instance

# Why Containers?
- isolation (app + libraries)
- portability 

# Docker
Docker Engine provides the runtime env.

Docker image is just a set of instructions on how to run a container instance off it.

- DockerHub is a repository of VMs
- When we launch a container, linux VM (say) will connect to DockerHub, download the image and create a container out of it
- You can go gto DockerHub, search for image such as nginx and run it on your machine
- sudo docker images will show you the images on your machine
- sudo docker run --name appnginx -p 80:80 -d nginx

To use Docker here are the steps:
- install docker engine on your machine
- find the image that you want to run (look it up on DockerHub)
- run it using "sudo docker run"
- or create an image based off your application

## Building a new image
To create from a .NET web app, simply publish it to a folder so that you have the webapp contents
- next build Dockerfile and place it along with the webapp code
- Dockerfile will have instructions on how to build my image
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY  . .
EXPOSE 80
ENTRYPOINT ["dotnet", "sqlapp.dll"]
```
1. The following command can be used to build a custom image<br>
sudo docker build -t sqlapp .

3. Use the following command as a reference to stop a running container<br>
sudo docker stop 9ec  [...9ec... is the first 3 characters of container id]

4. Then you can run a container out of your custom image<br>
sudo docker run --name sqlapp-1 -p 80:80 -d sqlapp

## Rebuilding image
"sudo docker ps" will show you the running containers<br>
"sudo docker rm 9ec" will remove the container<br>
"sudo docker rm sqlapp" will remove the image<br>

You can then rebuild/publish the image

We can also publish it on DockerHub so that other machines can also download and run an instance off it. OR publish it in Azure Container Registry (CR)

# Azure Container Registry
Repository for images. You can create a Azure CR resource (say appregistry2024) with a user id and password and later use that info to add images to it.

To do all this, you can install Azure CLI on a linux VM (refer install azure CLI on linux for that) and then use linux VM to publish images in CR.
- login in Azure CR using: sudo az acr login --name appregistry2024 --username <user> --password <pwd>
- next tag the sqlapp image we created previously with CR name
- sudo docker tag sqlapp appregistry2024.azurecr.io/sqlapp
- Push the image in CR
- sudo docker push appregistry2024.azurecr.io/sqlapp
- Now uder CR => Repositories you can see the sqlapp

It provides a fast and easy way to deploy containers.

## Multi stage Dockerfile
Earlier we built the code, publish to a folder, FTPed to a linux VM and there created the iamge of our web app.<br>

Here we have a Dockerfile that does build and create an image from .NET Core source code on linux VM itself

```Dockerfile
# https://hub.docker.com/_/microsoft-dotnet
FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build
WORKDIR /source

# copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore

# copy everything else and build app
COPY . .
RUN dotnet publish -c Release -o out

# final stage/image
FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY --from=build /source/out .
ENTRYPOINT ["dotnet", "sqlapp.dll"]
```

1. Build your new Docker image<br>
sudo docker build -t sqlapp-new .

2. Run your new container<br>
sudo docker run --name sqlapp-2 -p 80:80 -d sqlapp-new

## Azure Container Groups
This is a collection of containers that get schedules on the same host machine. They share the lifecycle, resources, local network and storage. The deployment is done via ARM or yaml file.

Here we can create a group of MySQL and sqlapp. Before all this it is a good practice to just create a resource of tyoe "MySQL" in azure and test your app outside of docker itself. On local; machine you can download and install MySQL Workbench and use it to connect to MySQL instance running in azure.

In .NET use MySql.Data in C# in order to use MySQL.

In DocketHub there is a MySQL image available that we can use to run on our linuxvm<br>
sudo docker run --name=mysql-instance -p 3306:3306 --restart on-failure -d -e MYSQL_ROOT_PASSWORD=Azure123 mysql

Then gon to linuxvm -> Settings -> Networking -> Add inbound port rule; and select MySQL as service and click on <Add>

Lets now containerize MySQL as we want it ti have our DB and data as well.

Here is Dockerfile to create a custom MySQL image. It starts with base image and runs SQL commands from 01.sql that creates Table and populates them

```
FROM mysql as base

ENV MYSQL_ROOT_PASSWORD=Azure123
ENV MYSQL_DATABASE=appdb

COPY 01.sql /docker-entrypoint-initdb.d/
```

```sql
###01.sql
CREATE TABLE Products
(
     ProductID int,
     ProductName varchar(1000),
     Quantity int
);

INSERT INTO Products(ProductID,ProductName,Quantity) VALUES
(1,'Mobile',100),
(2,'Laptop',200),
(3,'Tabs',300);
     	
```

```bash
1. Build the custom MySQL image
sudo docker build -t appsqlimage .

2. Run the image
sudo docker run -d -p 3306:3306 --name appsql appsqlimage

3. Connect to the container
sudo docker exec -it appsql bash

4. Launch the mysql shell to run mysql commands
mysql -uroot -p
```

## Push custom SQL image to CR

```bash
1. Tag the custom image
sudo docker tag appsqlimage companyregistry.azurecr.io/appsqlimage

2. Log into the container registry
sudo docker login companyregistry.azurecr.io -u companyregistry -p u0K36bwuW4E85jUFQL6l6d/jEtf7wA71

3. Push the image to the registry
sudo docker push companyregistry.azurecr.io/appsqlimage
```

## Now that we have it in CR, we can create a container instance out of it

## Deploying as a group

az container create --resource-group app-grp --file deployment.yml

deployment.yml
```yml
apiVersion: 2019-12-01
location: northeurope
name: SQLAppGroup
properties:
  containers: 
  - name: db
    properties:
      image: companyregistry.azurecr.io/appsqlimage:latest
      resources:
        requests:
          cpu: 1
          memoryInGb: 1.5
      ports:
      - port: 3306
  - name: web
    properties:
      image: companyregistry.azurecr.io/sqlapp:latest
      resources:
        requests:
          cpu: 1
          memoryInGb: 1.5
      ports:
      - port: 80          
  osType: Linux
  ipAddress:
    type: Public
    ports:
    - protocol: tcp
      port: 80
  imageRegistryCredentials:
    - server: companyregistry.azurecr.io
      username: companyregistry
      password: u0K36bwuW4E85jUFQL6l6d/jEtf7wA71
type: Microsoft.ContainerInstance/containerGroups
```

Note: The c# code can access MySQL using "localhost" instead of exact IP as they both run on same VM as a group.

## Azure Kubernetes
Just a managed platform for Kubernetes, it is used to manage containers on a scale. The first thing you do in Kubernetes is to create the cluster.
- Pod: A pod is used to group one or more containers. The Pod gets shared storage and network resources.
- Deployment: This is a declarative way to describve the state of the Pods and ReplicaSets. The deployment controller is used to ensure the desired state of the environment is always met.

### Create a "Kubernetes Service", specifying Node Size (CPU/RAM), Number of Nodes and Scaling (Manual/Auto)
- During  creation it will also ask which CR to integrate with, select the CR where your images are

Once cluster is ready, we can deploy our app (nginx in this case) as container via a service and deployment file.<br>
Under Kubernetes resources -> Workloads; we can use "Create with YAML" to deploy using our yaml file.
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
```

service.yml - this will comnfigure load balancer to access our service from outside world<br>
go to Kubernetes resources -> Services and ingresses; we can use "Create with YAML" to create service using our yaml file.<br>
service.yml
```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginxservice
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer
```


## Deploying ours (sqlapp + mysqlimage) in Kubernetes Cluster
Make sure the c# code use Server=mysql instead of IP or localhost as in the service.yml we set name as mysql<br>

Deploy these in Kubernetes resources -> Deployment and Kubernetes resources -> Services and Ingresses via YAML deployment

mysql-deployment.yml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: companyregistry.azurecr.io/appsqlimage:latest
        name: mysql
        ports:
        - containerPort: 3306
          name: mysql        
```

mysql-service.yml
```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

app-deployment.yml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - image: companyregistry.azurecr.io/kubernetesapp:latest
        name: myapp
        ports:
        - containerPort: 80
          name: myapp
```

app.service.yml
```yaml
apiVersion: v1
kind: Service
metadata:
  name: appservice
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer
```
